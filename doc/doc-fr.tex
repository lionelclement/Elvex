\documentclass[11pt]{article}

\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{epsfig}
\usepackage{hyperref}
\usepackage{gb4e}
\usepackage{enumitem}

\lstset{
  frame=single,
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  literate=  {→}{{$\rightarrow$}}1 {↓}{{$\downarrow$}}1 {↑}{{$\uparrow$}}1 {⇓}{{$\Downarrow$}}1 {⇑}{{$\Uparrow$}}1 {⊂}{{$\subset$}}1 {∪}{{$\cup$}}1
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {Ã}{{\~A}}1 {ã}{{\~a}}1 {Õ}{{\~O}}1 {õ}{{\~o}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1
{¬}{{$\lnot$}}1
}


\title{Elvex -- Documentation}
\author{Lionel Clément}
\date{version 2.10 -- (à mettre à jour)}

\begin{document}
\maketitle
\section{Le programme \texttt{elvex}}

\texttt{Elvex} est un générateur automatique de texte. Il prend en
entrée un concept, un lexique local, un lexique compacté, une
grammaire, et donne en sortie un texte correspondant au concept.

\subsection*{Compilation et installation complète d'Elvex}

La compilation complète d'\texttt{Elvex} réclame les éléments suivants sur sa machine:

\begin{itemize}
\item g++
\item flex
\item bison
\item aclocal
\item automake
\item autoconf
\end{itemize}

La commande complète est:

\begin{lstlisting}[frame=none, numbers=none]
aclocal
automake -fa
autoconf
./configure
make
sudo make install
\end{lstlisting}

\subsubsection{Essayer \texttt{Elvex}}

\begin{lstlisting}[frame=none, numbers=none]
. ./try-me.sh
\end{lstlisting}

\subsection{Commande \texttt{elvex}}

La commande d'\texttt{Elvex} est\\

\noindent
\verb#elvex [options] [input]*#\\

Où les options sont:

\begin{description}
\item \verb#-h|--help#

Affiche une aide et sort

\item \verb#-v|--version#

Affiche le numéro de version et sort

\item \verb#-a|--reduceAll#

  Réduit toutes les règles lors du processus de génération. Ce mode
  permet un débogage fin et demande de comprendre l'algorithme de
  génération pour être maitrisé.

\item \verb#-t|--trace#

  Affiche les règles réduites lors de la génération. Ce mode permet un
  débogage de la grammaire.

\item \verb#-r|--random#
  
  N'affiche qu'une seule sortie choisie au hasard.
  
\item \verb#-rulesFile <file>#
  
  Fichier contenant la grammaire. 
  
\item \verb#-lexiconFile <file>#
  
  Fichier contenant le lexique.

\item \verb#-inputFile <file>#
  
  Fichier contenant l'input. 
  
\item \verb#-compactDirectory <directory>#

  Répertoire contenant les fichiers du lexique compacté.

\item \verb#-compactLexiconFile <filePrefix>#

  Préfixe des fichiers du lexique compacté
  \verb#<directory>/<filePrefix>.tbl# et
  \verb#<directory>/<filePrefix>.fsa#
  
\item \verb#-maxLength <integer>#

  Définit la longueur maximale de la séquence à produire.

\item \verb#-maxUsages <integer>#

  Définit le nombre maximal d'utilisation de la même règle.

\item \verb#-maxCardinal <integer>#

  Définit la cardinalité maximale des ensembles d'items.

\item \verb#-maxTime <integer>#

  Définit le nombre de secondes avant l'arrêt du programme.

\end{description}

\subsection{Commande \texttt{elvexdebug} pour débogage des grammaires}

\noindent
\verb#elvexdebug [options] [input]*#\\

La commande \texttt{elvexdebug} fonctionne de la même manière avec les
mêmes options mais produit un document \texttt{HTML} en sortie
standard. Ce document, à lire à l'aide d'un navigateur, permet de suivre les calculs
d'\texttt{Elvex}. 

La commande \texttt{elvexdebug} est recommandable pour mettre au
point les grammaires dans les cas les plus difficiles.

\subsection{Commande \texttt{elvexbuildlexicon} pour la gestion des
  gros lexiques}

\noindent
\verb#elvexbuildlexicon [global-option] <build|consult|test> <input>#\\

 Où les options sont:

\begin{description}
\item \verb#-h|--help#

Affiche une aide et sort

\item \verb#-d <directory>#

  Répertoire contenant les fichiers du lexique compacté.

\item \verb#-f <filePrefix>#

  Préfixe des fichiers du lexique compacté \verb#<directory>/<filePrefix>.tbl# et \verb#<directory>/<filePrefix>.fsa#.
  
\end{description}

\subsubsection*{Commande pour construire un lexique}

\begin{description}
\item \verb#$buildlexiconmain -d <directory> -f <filePrefix> build <input># 
\end{description}

\subsubsection*{Commande pour tester un lexique}

\begin{description}
\item \verb#$buildlexiconmain -d <directory> -f <filePrefix> test# 

\subsubsection*{Commande pour consulter un lexique}

\item \verb#$buildlexiconmain -d <directory> -f <filePrefix> consult# 

\end{description}

Le lexique compacté est un ensemble d'entrées lexicales de type

\paragraph{}\verb@cat#lexème	forme#FS@

\begin{itemize}
\item \verb#cat# est une catégorie lexicale
\item \verb#lexème# est le lexème que l'on trouve comme valeur du
  trait \verb#HEAD#
\item \verb#forme# est la forme produite (une chaine de caractères
  UTF8 dans la version 2.10)
\item \verb#FS# est la structure de traits de l'entrée lexicale
\end{itemize}

\newpage
\section{Grammaire}

Un exemple permettra de familiariser le lecteur avec \texttt{Elvex}
avant d'aller plus loin. Nous prendrons le cas de la génération d'un
groupe nominal en français.

\subsubsection*{Exemple}

\begin{lstlisting}
@rules
/* **************************************************
 * Elvex rules
 ************************************************** */
NP → det N {
  ↓2 = ↑;
  ↓1 = ⇓2;
}

N → adj N {
  [mod:<$Head::$Tail>, $Rest];
  [number:$NInh] ⊂ ↑;
  ↓1 = $Head ∪ [number:$NInh, gender:$GSynth];
  ↓2 = [mod:$Tail, $Rest];
  [gender:$GSynth] ⊂ ⇓2;
  ⇑ = ⇓2 ∪ [qual:yes];
}

N → n {
  [mod:NIL];
  ↓1 = ↑;
  ⇑ = ⇓1;
}
\end{lstlisting}

\subsection{Règles syntagmatiques (\textit{Context-Free Grammar})}
 
La première règle de la grammaire (ligne 5) définit \texttt{NP} comme
constitué de \texttt{det} et \texttt{N} dans cet ordre.

\texttt{det} est un mot; il n'est pas définit dans la grammaire, mais
dans le lexique que nous verrons plus loin.

Les lignes 10) et 19) suivent cette même logique et nous avons la
grammaire hors contexte suivante:

\begin{lstlisting}[numbers=none]
NP → det N
N → adj N
N → n
\end{lstlisting}

La seule séquence que nous pouvons générer avec ce simple exemple est
un nom, précédé d'un déterminant et éventuellement d'un adjectif.

Les règles syntagmatiques sont donc faites pour décrire l'ordre des
constituants des syntagmes, des phrases et des discours.

\subsubsection*{Règles vides, termes optionnels}
 
Il est possible d'écrire des règles vides, c'est-à-dire des
constituants qui n'ont aucune réalisation en production de texte. Il
est aussi possible de mettre des éléments optionnels. Ils sont alors
écrit entre crochets \verb#[]#.

Exemple:
La règle suivante donne toutes les combinaisons possibles pour les
pronoms clitiques placés avant le verbe.

\begin{lstlisting}[numbers=none]
  CLITICS → [clr] [cld] [cla] [cld] [clg] [cll] 
\end{lstlisting}

Le clitique datif (\texttt{cld}) est tantôt placé avant, tantôt
placé après le clitique accusatif (\texttt{cla}) selon la
personne. (\textit{Jean \textbf{me} \textbf{le} donne}, \textit{Jean
  \textbf{le} \textbf{lui} donne.}).

Selon cette règle, le syntagme \texttt{CLITICS} peut être vide.

\subsubsection*{Paradigmes}

Chaque élément d'une règle syntagmatique peut être une liste de termes
séparés par le signe \verb#|# au lieu d'être un terme unique. Dans ce
cas, le syntagme produit est construit avec l'un des termes de la liste.

Exemple:
La règle suivante permet de construire une phrase sans sujet, avec un
sujet clitique nominatif \texttt{cln} (\textit{je}, \textit{tu},
\textit{il}, $\dots$), ou avec un sujet sous forme d'un groupe nominal.

\begin{lstlisting}[numbers=none]
S → [cln | NP] VP
\end{lstlisting}

Une grammaire écrite en utilisant massivement les règles avec des
alternatives et des termes optionnels revient à une grammaire très
grosse qui pose des problèmes d'explosion combinatoire. Par exemple la
règle décrivant l'ordre des pronoms clitiques est équivalente à un
ensemble de 64 règles:
 
\begin{lstlisting}[numbers=none]
  CLITICS → 
  CLITICS → clr 
  CLITICS → cld 
  ...
  CLITICS → clr cld 
  CLITICS → clr cl cla
  ... ...
\end{lstlisting}

Cependant \texttt{Elvex} ne construit jamais ces ensembles de règles
et reste efficace avec de très grosses grammaires ainsi
écrites. L'usage des alternatives et des termes optionnels est donc
préconisé pour décrire l'ordre des mots, sans se soucier de
l'explosion combinatoire évoquée plus haut.

\subsection{Opérations de sémantique opérationnelle}

Chaque règle contient un ensemble d'opérations en sémantique
opérationnelle. Ces opérations décrivent les propriétés fonctionnelles
de la langue qui dépendent ou non de l'ordre des mots.

\subsubsection*{Les bases}

Nous allons expliquer cette sémantique à travers l'exemple donné au
début de cette section avant de donner des détails.

\begin{itemize}
\item Les règles des lignes 6 et 7 expriment la nature des liens qui
  existent entre \texttt{NP}, le nom \texttt{N} et son déterminant
  \texttt{det}; le principal étant qu'ils s'accordent en genre et en
  nombre.

  \begin{itemize}
  \item La règle 6) attribue au nom les propriétés du groupe
    nominal. Les attributs du nom sont notés $\downarrow2$ (c'est le
    second terme de la partie droite de la règle), ceux du
    groupe nominal $\uparrow$.
  \item La règle 7) récupère les informations issues des
    analyses de \texttt{N} pour les attribuer au déterminant.  Les
    attributs du déterminant sont notés $\downarrow1$ (c'est le premier
    terme de la partie droite de la règle), ceux issues du nom \texttt{N}
    $\Downarrow2$.
  \end{itemize}
  
  Avec ces deux règles, le nom sera choisi dans le lexique en fonction
  du concept à exprimer (attribut du groupe nominal $\uparrow$).  Un
  déterminant singulier féminin sera choisi si le nom est de genre
  féminin et que le groupe nominal est singulier.
  
  Ce mécanisme, qui permet d'articuler les choix lexicaux en fonction des
  concepts et les propriétés syntaxiques en fonction des propriétés
  lexicales, est au coeur d'\texttt{Elvex} et met en {\oe}uvre deux types
  d'attributs: les attributs hérité (notés $\uparrow$, $\downarrow_i$)
  et les attributs synthétisé (notés $\Uparrow$, $\Downarrow_i$).
  
  Les attributs hérités sont calculés de gauche à droite des règles
  syntagmatiques, les attributs synthétisé sont calculés de droite à
  gauche. Pour faire simple, nous pouvons dire que les attributs hérités
  véhiculent des informations données depuis l'\textit{input} vers le
  lexique, et que les attributs synthétisés véhiculent des informations
  venant du lexique vers des couches plus hautes de l'analyse. Ainsi la
  règle 6) permet de propager l'\textit{input} vers le lexique pour
  réaliser un choix lexical, alors qu'à l'inverse, la règle 7) permet de
  récupérer les informations lexicales du nom choisi en fonction du
  concept exprimé et de propager ces informations (le genre, les
  restrictions de sélection, les contraintes d'une expression
  phraséologique, etc) vers le groupe nominal entier.
  
\item Les règles des lignes 11 à 16 permettent de régler l'accord en
  genre et nombre du nom et de l'adjectif et aussi de propager les
  concepts qui produisent les adjectifs. On remarque qu'en français,
  le nombre est un sémantème exprimé directement sous la forme d'un
  signe associé au substantif, alors que le genre est une marque
  morphologique du lexique. Le premier sera propagé depuis le concept d'un nom, le
  second sera propagé depuis le lexique vers les couches réglant
  l'accord.
  
  \begin{itemize}
  \item La règle 11) est une \textit{garde}, c'est-à-dire une
    condition de réalisation de la production
    $\mathtt{N} \rightarrow \mathtt{adj}~ \mathtt{N}$. Elle exprime le
    fait que la réalisation d'un adjectif est conditionnée par
    l'existence d'une liste\\
    \verb#<$Head::$Tail># comme valeur d'un attribut \texttt{mod}
    dans l'attribut hérité $\uparrow$.
    
    \verb#$Head# et
    \verb#$Tail# sont deux variables qui définissent respectivement la
    tête et la queue d'une liste, c'est-à-dire respectivement le
    premier élément de la liste et le reste de cette liste.
    
    Si la condition de cette garde est réalisée, alors
    \verb#$Head#, \verb#$Tail# et
    \verb#$Rest# seront affectées par des valeurs données par la
    subsomption\footnote{Une structure de traits \texttt{A} subsume
      une structure de traits \texttt{B} si tous les traits de
      \texttt{B} sont présents dans \texttt{A} avec des valeurs
      équivalentes ou avec des valeurs qui subsument celles des
      valeurs de \texttt{A}.}  de \verb#[mod:<$Head::$Tail>, $Rest]#
    par $\uparrow$.
    
  \item La règle 12) affecte la variable
    \verb#$NInh# (\textit{Inherited noun}) avec la valeur du trait
    \texttt{number} de l'attribut hérité
    $\uparrow$. Ceci permet de récupérer le nombre donné au groupe
    nominal.
    
  \item La règle 13) affecte à l'attribut hérité de l'adjectif la tête
    de la liste \verb#$Head# unifiée\footnote{L'unification d'une
      structure de traits \texttt{A} avec une structure de traits
      \texttt{B}, est la plus petite structure de traits \texttt{C}
      telle que \texttt{A} subsume \texttt{C} et \texttt{B} subsume
      \texttt{C}.  Pour un éclairsissement de ces notions de
      subsomption et d'unification, voir par exemple l'introduction du
      livre \textit{Les grammaires d'unification}, Anne Abeillé,
      Lavoisier 2007, Coll. langues et syntaxe, Paris} avec une
    structure qui donne le genre synthétisé
    \verb#$GSynth# (\textit{synthesized gender}) et le nombre hérité
    \verb#$NInh#.
    
  \item La règle 14) affecte à l'attribut hérité du nom l'ensemble des
    valeurs passées par héritage (\verb#$Rest#) et ajoute le trait
    \verb#mod# avec comme valeur
    \verb#$Tail#, c'est-à-dire la queue de la liste qui rassemble
    l'ensemble des autres modifieurs du nom (autre adjectif ou une
    proposition relative par exemple).
    
  \item La règle 15) permet d'affecter la  variable \verb#$GSynth#
    qui est le genre synthétisé à partir du nom.
    
  \item Enfin la règle 16) transmet comme attribut synthétisé l'attribut
    synthétisé du nom et ajoute l'information que cet attribut
    est qualifié (ce qui permet de restreindre par exemple d'autres
    modifications avec un adjectif léger).
    
\end{itemize}

\item Les règles des lignes 20 à 22 ne présentent rien de particulier,
  à part la garde de la règle 20) qui met en {\oe}uvre la valeur
  \verb#NIL#.

  \begin{itemize}    
  \item La règle 20) est une garde telle que l'attribut hérité
    $\uparrow$ ne contient aucun trait \texttt{mod}. \verb#mod:NIL#
    signifie que l'attribut \verb#mod# n'existe pas dans $\uparrow$.
    
  \item Les règles 21) et 22) ne demandent aucun commentaire
    supplémen-taire.
    
  \end{itemize}
\end{itemize}

Il devient clair en examinant cet exemple simple que l'ordre des
règles opérationnelles n'est pas celui donné par la grammaire, mais
celui dicté par les disponibilités des opérandes. Ici, un ordre possible
d'application des règles est 11), 12), 14), 15), 13) et 16). Dans la
version 2.10 d'\texttt{Elvex} cet ordre est calculé à la volée. Dans
les versions ultérieures un graphe de dépendance sera construit avec
des indications permettant de mettre au point les grammaires sur ce
point précis.

Le conseil que je peux donner pour mettre au point une grammaire est
d'écrire les règles au fur et à mesure que les attributs synthétisés
sont disponibles.

On voit que les règles syntagmatiques ne sont pas produites
linéairement de gauche à droite et de haut en bas, mais de façon a
priori indéterminée en produisant les éléments disponibles en premier.

Avant d'aller plus loin, donnons des définitions sur les notations qui
  nous permettent de comprendre la syntaxe des règles.
  
\subsection*{Syntaxe de la grammaire}
 
 Une règle syntagmatique s'écrit 

$A~ \rightarrow B_1 B_2 \dots B_K <operational~semantics>;$
 
Où $B_i$ s'écrit:

\begin{itemize}
\item $[ B_i ]$ si le terme $B_i$ est optionnel.
\item $C_1 | C_2 | \dots | C_n$ si le terme $B_i$ est l'alternative
  entre les $C_i$
\end{itemize}
 
$B_i$, $C_i$ peuvent être des catégories lexicales ou des termes de la
grammaire.

\subsubsection*{Sémantique opérationnelle}

\paragraph{Notations}

Soit la règle $A~ \rightarrow B_1 B_2 \dots B_i \dots B_k <operational~semantics>$

\begin{itemize}
\item $\uparrow$: désigne l'attribut hérité de $A$.
\item $\downarrow_i$: désigne l'attribut hérité de $Bi$.
\item $\Uparrow$: désigne l'attribut synthétisé de $A$.
\item $\Downarrow_i$: désigne l'attribut synthétisé de $Bi$. 
\end{itemize}

Les variables nommées sont notées par un identifiant précédé de \og
\$\fg{}, les variables libres sont notées \og \verb#_#\fg{}, les
valeurs constantes sont notées par des identifiants.

Les structures de traits sont notées $[ trait_1, trait_2, \dots , trait_k ]$ où $trait_i$ est
\begin{itemize}
\item soit une variable libre
\item soit une variable nommée
\item soit \verb#FORM:"<form>"# un trait pour une forme littérale
\item soit $attr_i:val_i$
  \begin{itemize}
  \item avec $attr_i$ le nom d'un attribut ou \texttt{HEAD} ou \texttt{FORM}
  \item et avec $val_i$ la valeur d'un attribut qui peut être: 
    
    \begin{itemize}
    \item Une variable nommée
    \item Une variable libre
    \item Une valeur nulle (\texttt{NIL})
    \item Un ensemble de constantes atomiques séparées par \verb#|#
    \item Une constante littérale (nombre)
    \item Une structure de traits
    \item Une liste
    \end{itemize}
  \end{itemize}
  
\end{itemize}

Les listes sont notées
\begin{itemize}
\item $<l_1, l_2, \dots, l_k>$ avec $l_i$ structure de traits
\item $<head::tail>$ avec $head$ structure de traits et $tail$, liste ou variable nommée ou non\\
  $head$ désigne le premier élément de la liste, $tail$ le reste de la liste.\\
\end{itemize}

 Si l'on souhaite apporter une sémantique opérationnelle à la règle syntagmatique, on
définit $<operational~semantics>$ qui est une liste de règles entre accolades.

Chaque règle s'écrit:

\begin{itemize}

\item $\{<$liste de règles $>\}$ Une liste de règles.

\item \verb#attest <expr>;# Garde explicite où \verb#<expr># est une
  expression booléenne qui doit être vérifiée.

\item \verb#[attr, attr, ..., attr];# Garde où la structure de traits
  doit subsumer $\uparrow$. La garde peut contenir le trait
  \verb#HEAD# qui représente le concept à générer. Ainsi, un concept
  n'est pas nécessairement lié à une entrée lexicale avec
  \texttt{Elvex}, contrairement aux systèmes de génération de texte
  habituels; il peut produire une contrainte syntaxique.

\item \verb#print <expr>;# Affiche l'expression en sortie standard
  (utile pour le débogage).

\item \verb#println <expr>;# Fait la même chose en affichant une
  nouvelle ligne.
  
\item  \verb#<expr1> = <expr2>;#
  
  Une affectation de l'expression $<expr1>$ avec la valeur de
  l'expression $<expr2>$. L'expression $<expr1>$ est une variable
  complexe ou simple, l'expression $<expr2>$ est une constante ou une
  variable complexe ou simple telle qu'il existe un
  environnement\footnote{Un environnement est une application $\phi$
    de $E$ dans $F$ telle que $E$ est un ensemble de variables et $F$
    un ensemble de constantes ou de variables. La résolution d'une
    variable $\alpha$ dans par un environnement est
    $\beta = \phi^k(\alpha)$ tel que $\beta$ est une constante. Notons
    qu'\texttt{Elvex} manipule aussi les variables complexes. Dans ce cas
    $\phi^k(\alpha)$ revient à remplacer les variables dans les
    termes par leurs constantes.} de la règle syntagmatique pour le
  résoudre.
  
  Les affectations de $\uparrow$ et $\Downarrow_i$ ne sont pas
  possibles, car ces attributs sont implicitement évalués lors de la
  génération de texte et leur modification provoquerait des
  incohérences.

Les affectations se résument à ces cas:

  \begin{itemize}
    
  \item  Affecter une liste
    \begin{itemize}
    \item  \verb#<#$\dots$\verb#> = <#$\dots$\verb#># Affecte une liste à
      une autre.
    %\item \verb#<#$\dots$\verb#> = sort #$\dots$ Affecte une liste triée à
    %  une autre.
    %\item \verb#<#$\dots$\verb#> = reverse #$\dots$ Affecte une liste
    %  renversée à une autre.
    \item \verb#<#$\dots$\verb#> = $X# Affecte à une liste la valeur de la
      variable \verb#$X#
    \end{itemize}
    
  \item  Affecter un attribut hérité
    \begin{itemize}
    \item $\downarrow$\verb#i = [#$\dots$\verb#]# Affecte une
      structure de traits constante ou variable.
    \item $\downarrow$\verb#i = #$\uparrow$ Affecte un attribut hérité.
    \item $\downarrow$\verb#i = #$\dots$\verb# #$\cup$\verb# #$\dots$
      Affecte le résultat de l'unification de deux expressions
      (structures de traits ou attributs).
    \item $\downarrow$\verb#i = #$\Downarrow$\verb#j# Affecte un
      attribut synthétisé.
    \end{itemize}
    
  \item  Affecter un attribut synthétisé
    \begin{itemize}
    \item $\Uparrow$\verb# = $X#
    \item $\Uparrow$\verb# = [#$\dots$\verb#]#
    \item $\Uparrow$\verb# = #$\uparrow$
    \item $\Uparrow$\verb# = #$\dots$\verb# #$\cup$\verb# #$\dots$
    \item $\Uparrow$\verb# = #$\Downarrow$\verb#j#
    \end{itemize}
    
  \item  Affecter une variable simple
    \begin{itemize}
    \item \verb#$X = $Y#
    \item \verb#$X = a# Affecte par une constante ou un littéral.
    \item \verb#$X = <#$\dots$\verb#>#
    %\item \verb#$X = sort #$\dots$
    %\item \verb#$X = reverse #$\dots$
    \item \verb#$X = [#$\dots$\verb#]#
    \item \verb#$X = #$\uparrow$
    \item \verb#$X = #$\dots$\verb# #$\cup$\verb# #$\dots$
    \item \verb#$X = #$\Downarrow$\verb#j#
    \item \verb#$X = <expr>#  par l'évaluation d'une expression
      arithmétique ou logique.
    \end{itemize}
    
  \item  \verb#[#$\dots$\verb#]# $\subset$ \verb#<expr>;#

    Subsume une structure de traits

     \begin{itemize}
    \item \verb#[#$\dots$\verb#] #$\subset$\verb# #$\uparrow$ par un
      attribut hérité
    \item \verb#[#$\dots$\verb#] #$\subset$\verb# #$\Downarrow$\verb#j# par un attribut synthétisé
    \item \verb#[#$\dots$\verb#] #$\subset$\verb# $X# par la valeur
      d'une variable 
    \end{itemize}
    
  \item \verb#if (<boolExpr>) <rules>#
    
Interprète la sémantique opérationnelle \verb#<rules># si et seulement
si l'expression \verb#<boolExpr># est vérifiée.



\item \verb#if (<boolExpr>) <rules1> else <rules2>#

Interprète la sémantique opérationnelle \verb#<rules1># si et
seulement si \verb#<boolExpr># est vérifiée, sinon interprète \verb#<rules2>#.

\end{itemize}

Une expression logique \verb#<booExpr># est

     \begin{itemize}
    \item \verb#<boolExpr>#  $\lor$ \verb#<boolExpr># Ou logique
    \item \verb#<boolExpr>#  $\land$ \verb#<boolExpr># Et logique
    \item $\neg$ \verb#<boolExpr># Négation logique
    \item \verb#<boolExpr>#  $\Rightarrow$ \verb#<boolExpr>#
      Implication logique
    \item \verb#<boolExpr>#  $\Leftrightarrow$ \verb#<boolExpr>#
      Équivalence logique
    \item \verb#<expr>#  $==$ \verb#<expr># Égalité entre deux expressions
    \item \verb#<expr>#  $\neq$ \verb#<expr># Différence entre deux expressions
    \item \verb#<expr># Expression évaluée comme booléen: Une
      structure de traits est évaluée comme vraie si elle n'est pas
      \verb#NIL# ou $\bot$ (résultat de l'échec de l'unification
      entre deux structures de traits).
    \end{itemize}

Les expressions sont:

     \begin{itemize}
    \item Entier
    \item Chaine de caractères
    \item \verb#<expr>#  $\cup$ \verb#<expr># Unification de deux
      structures de traits
    \item $\uparrow$
    \item $\Uparrow$
    \item $\downarrow_i$
    \item $\Downarrow_i$
    \item \verb#[...]# Structure de traits
    \item \verb#NIL# Valeur nulle d'un trait
    \item \verb#a|b...# Constante
    \item \verb#$xxx# Variable
    \item \verb#<...># Liste
    \end{itemize}
    
Ajoutons les expressions algébriques et les nombres:

     \begin{itemize}
    \item \verb#<expr>#  $<$ \verb#<expr>#
    \item \verb#<expr>#  $\le$ \verb#<expr>#
    \item \verb#<expr>#  $>$ \verb#<expr>#
    \item \verb#<expr>#  $\ge$ \verb#<expr>#
    \item \verb#<expr>#  $+$ \verb#<expr>#
    \item \verb#<expr>#  $-$ \verb#<expr>#
    \item \verb#<expr>#  $*$ \verb#<expr>#
    \item \verb#<expr>#  \% \verb#<expr>#
    \item \verb#<expr>#  $/$ \verb#<expr>#
    \item $-$ \verb#<expr>#
    \item Double flottant
    \end{itemize}
    
\end{itemize}

\subsubsection*{Évaluation des variables}

Les variables sont évaluées localement à une règle syntagmatique. Cela
définit la portée d'une variable.

Voici différentes méthodes permettant de résoudre les variables:

\begin{itemize}
\item Affectation directe
\begin{lstlisting}
S → S {
  [vform:NIL];
  [tense:$tense, aspect:$aspect, mode:$mode] ⊂ ↑;
  if (!$tense)
    $tense=present;
...
}
\end{lstlisting}
La ligne 5 indique que la valeur de la variable \verb#$tense# est
\verb#present# à défaut d'une autre valeur donnée préalablement. La
valeur de
\verb#$tense# est éventuellement donnée par l'attribut hérité
$\uparrow$ en ligne 3.

Noter que l'ordre d'évaluation des règles est indifférent et qu'il
n'est pas nécessaire de faire précéder la règle 3) dans l'ordre
d'écriture des règles.

\item Garde
\begin{lstlisting}[numbers=none]
S → NP VP {
  [subject:$subjectInherited, $Rest];
...
}
\end{lstlisting}

La valeur de la variable \verb#$subjectInherited# est donnée 
par le trait \verb#subject# de $\uparrow$. La valeur de la variable 
\verb#$Rest# est la structure de traits qui reste quand on retire le
trait \verb#subject#.

\item Subsomption
\begin{lstlisting}[numbers=none]
S → NP VP {
...
  [subject:$subjectSynthesized] ⊂ ⇓2;
...
}
\end{lstlisting}

La valeur de la variable \verb#$subjectSynthesized# est donnée 
par le trait \verb#subject# de $\Downarrow2$. 

\item Liage d'une variable au sein d'une règle syntagmatique
\begin{lstlisting}[numbers=none]
S → NP VP {
  [subject:$subjectInherited, $Rest];
  [subject:$subjectSynthesized] ⊂ ⇓2;
  ↓1 = [subject:$subjectInherited] 
  		∪ [subject:$subjectSynthesized];
...
}
\end{lstlisting}

Les variables \verb#$subjectSynthesized# et \verb#$subjectInherited#
sont toutes deux exploitées au sein de cette règle pour  être
transmises au trait \verb#subject# de l'attribut hérité $\downarrow1$.

\item Liage d'une variable au sein d'une entrée lexicale

\begin{lstlisting}[numbers=none]
a	v[HEAD:fog, subjC:[FORM:"il"], 
		objC:[HEAD:brouillard, det:yes, 
		def:no, part:yes, neg:$Neg], 
		locCl:[HEAD:_pro, number:sg, 
			person:three], 
		vform:tensed, vtense:present, 
		mode:indicative, 
		subj:[person:three, number:sg], 
		neg:$Neg, fct:none]
\end{lstlisting}

La variable \verb#$Neg# est liée dans cette entrée lexicale de l'expression "il y
a du brouillard" de sorte que son emploi au négatif propage un négatif
du substantif:

\begin{exe}
\ex \begin{xlist} 
\ex \label{0-a} \textit{Il y a du brouillard}
\ex \label{0-a}  \textit{Il n'y a pas de brouillard}
\ex \label{0-a} \textit{*Il y a de brouillard}
\ex \label{0-a} \textit{*Il n'y a pas du brouillard}
\end{xlist}
\end{exe}

\end{itemize}



\subsection{Lexique}

Le lexique est une liste d'entrées séparées par des point-virgules.

Chaque entrée définit la séquence à produire, suivie d'une disjonction
(notée par le caractère \verb#|#) de catégories lexicales
optionnellement suivies d'une structure de traits.

La séquence à produire peut être:

\begin{itemize}
\item Une chaine de caractères entre \verb#""#, auquel cas la séquence
  produite sera exactement celle-ci. À noter que la séquence peut être vide.

\item Une chaine de caractères entre \verb#""# contenant des
  variables. La séquence produite sera celle-ci avec les variables
  substituées pas leur valeurs respectives.

\item \texttt{FORM}: la séquence produite sera littéralement celle
  donnée par le trait \texttt{FORM}. La version 2.10 ne prévoit que
  des \texttt{FORM} constantes, les versions ultérieures auront aussi
  des variables complexes.

\end{itemize}

La catégorie est un identifiant, symbole terminal de la grammaire.

La structure de traits permet de représenter l'ensemble des
contraintes imposées par le lexique.

Quelques exemples:

\begin{itemize}
\item \verb#"?" interrogativeDot;#

\bigskip
\item \verb#"tag-$Line" tag[line:$Line]; #

\bigskip
\item \verb# FORM title; #

\bigskip
\item \verb#"elles-mêmes"	itself [gender:fm, number:pl, person:three, itself:yes]; #

\bigskip
\item \begin{verbatim}
serai	aux_être [aux:être, voice:active, finite:yes,
  mode:indicative,  vtense:future_anterieur, vform:tensed, 
subj:[person:one, number:sg]]; 
\end{verbatim}

\bigskip
\item \begin{verbatim}
// Entrée lexicale "temperature" produisant 
"la température est de xxx degrés" avec [cel:xxx]
est v[HEAD:temperature, 
	subjC:[HEAD:température, number:sg, det:yes, def:yes], 
	pobjC:[HEAD:degré, number:pl, pcas:de, det:yes,
		detNum:[HEAD:num, value:$Deg]], 
	vform:tensed, vtense:present, mode:indicative, 
	subj:[person:three, number:sg], fct:none, value:$Deg]

"la température est douce"
|v[HEAD:temperature, subjC:[HEAD:température, number:sg, 
	det:yes, def:yes], modC:[HEAD:doux, number:sg, gender:fm],
	vform:tensed, vtense:present, mode:indicative, 
	subj:[person:three, number:sg], fct:few]

"la température est élevée"
|v[HEAD:temperature, subjC:[HEAD:température, number:sg, 
	det:yes, def:yes], modC:[HEAD:élevé, number:sg, gender:fm],
	vform:tensed, vtense:present, mode:indicative, 
	subj:[person:three, number:sg], fct:much];
\end{verbatim}

\bigskip
\item \begin{verbatim}
// Entrée lexicale de "temperature"
// produisant "Il fait chaud"
fait	v[HEAD:temperature, subjC:[FORM:"il"], 
	modC:[HEAD:chaud, number:sg, gender:ms], vform:tensed,
	vtense:present, mode:indicative, 
	subj:[person:three, number:sg], neg:$Neg, fct:high]

//"Il fait très chaud"
|v[HEAD:temperature, subjC:[FORM:"il"], modC:[HEAD:chaud, 
	number:sg, gender:ms, mod:<[HEAD:très]>], vform:tensed, 
	vtense:present, mode:indicative, subj:[person:three, 
	number:sg], neg:$Neg, fct:very_high]

//"Il fait très froid"
|v[HEAD:temperature, subjC:[FORM:"il"], modC:[HEAD:froid, 
	number:sg, gender:ms, mod:<[HEAD:très]>], vform:tensed,
	vtense:present, mode:indicative, subj:[person:three, 
	number:sg], neg:$Neg, fct:very_low]

//"Il fait froid"
|v[HEAD:temperature, subjC:[FORM:"il"], modC:[HEAD:froid, 
	number:sg, gender:ms], vform:tensed, vtense:present, 
	mode:indicative, subj:[person:three, number:sg], 
	neg:$Neg, fct:low]; 
\end{verbatim}
	
\bigskip
\item \begin{verbatim}
// entrée lexicale de "pleuvoir" produisant
// "il y a une pluie fine"
a	v[HEAD:pleuvoir, subjC:[FORM:"il"], 
	objC:[HEAD:pluie, det:yes, number:sg, qual:yes,
		def:no, mod:<[HEAD:fin, pos:post]>], 
	locCl:[HEAD:_pro, number:sg, person:three], 
	vform:tensed, vtense:present, mode:indicative, 
	subj:[person:three, number:sg], neg:$Neg, fct:few]
	
// "il y a un peu de pluie"
|v[HEAD:pleuvoir, subjC:[FORM:"il"], 
	objC:[HEAD:pluie, det:yes, number:sg, 
	detForm:[FORM:"un peu de"]], 
	locCl:[HEAD:_pro, number:sg, person:three], 
	vform:tensed, vtense:present, mode:indicative, 
	subj:[person:three, number:sg], neg:$Neg, fct:not_much]

// "il y a beaucoup de pluie"
|v[HEAD:pleuvoir, subjC:[FORM:"il"], 
	objC:[HEAD:pluie, det:yes, number:sg, 
	detForm:[FORM:"beaucoup de"]], 
	locCl:[HEAD:_pro, number:sg, person:three], 
	vform:tensed, vtense:present, mode:indicative, 
	subj:[person:three, number:sg], neg:$Neg, fct:much]

// "il y a de fortes précipitations"
|v[HEAD:pleuvoir, subjC:[FORM:"il"], 
	objC:[HEAD:précipitation,
        det:yes, number:pl, qual:yes, def:no, mod:<[HEAD:fort,
        pos:pre]>], locCl:[HEAD:_pro, number:sg, person:three],
        vform:tensed, vtense:present, mode:indicative,
        subj:[person:three, number:sg], neg:$Neg, fct:a_lot]; 
\end{verbatim}

\end{itemize}

\subsection{Input}

L'input se résume au nom du syntagme que l'on souhaite générer, suivi d'une
structure de traits.

\texttt{HEAD} permet de définir le concept à générer. Concept
correspondant à un lexème ou à une construction syntaxique particulière.

exemples

\begin{itemize}
\item 
\begin{verbatim}
sentence [HEAD:pleuvoir, neg:yes]
\end{verbatim}

Simple entrée pour le concept de \textit{pleuvoir} produisant 
\begin{exe}
\ex \begin{xlist} 
\ex \textit{Il ne pleut pas}
\ex \textit{Il n'y a pas de pluie}
\end{xlist}
\end{exe}


\item 
\begin{verbatim}
sentence [HEAD:demander,
    i:[HEAD:menuisier, id:3, number:sg, gender:ms, def:yes],
    iii:[HEAD:apprenti, id:6, def:yes, gender:ms, number:sg],
    ii:[HEAD:scier,
	 i:[idref:6],
	 ii:[HEAD:poutre, number:sg, def:yes]
	 ]
    ]
\end{verbatim}

Concept complexe où les traits \texttt{id} et \texttt{idref}
permettent de contraindre les coréférences. 
Cette entrée produit 

\begin{exe}
\ex \textit{Le menuisier demande à l'apprenti de scier la
poutre}
\end{exe}

\item 
\begin{verbatim}
sentence [HEAD:pleuvoir, tense:future, modSType:time, 
modS:<[FORM:"lundi 18 mars 2019", type:time]>]
\end{verbatim}

Concept produisant une adverbiale sur la base de la
constante "lundi 18 mars 2019". Cette entrée produit 

\begin{exe}
\ex \textit{Il va pleuvoir le lundi 18 mars 2013.}
\end{exe}

\item 
\begin{verbatim}
sentence [HEAD:cause, 
    i: [HEAD:pleuvoir]]
    ii: [HEAD:se_couvrir, i:[HEAD:you], modality:devoir]
]
\end{verbatim}

Entrée pour 
\begin{exe}
\ex \begin{xlist} 
\ex \textit{Il pleut, tu dois te couvrir}
\ex \textit{Il pleut, par conséquent tu dois te couvrir}
\ex \textit{Tu dois te couvrir s'il pleut}
\ex \textit{Tu dois te couvrir car il pleut}
\ex \textit{S'il pleuvait, tu devrais te couvrir}
\ex \textit{S'il pleut, tu devras te couvrir}
\ex \textit{Il pleuvrait, tu devrais te couvrir}
\end{xlist}
\end{exe}

\item 
\begin{verbatim}
sentence [HEAD:initiative, i:[HEAD:Jean], 
objC:[lexFct:Magn, mod:<[HEAD:audacieux]>], lexFct:Oper1]
\end{verbatim}

Input contenant des traits pour fixer des fonctions lexicales. La
production est 
\begin{exe}
\ex \textit{Jean prend une initiative très audacieuse.}
\end{exe}

\item 
\begin{verbatim}
sentence [HEAD:initiative, i:[HEAD:Jean], 
objC:[lexFct:Magn], lexFct:Oper1]
\end{verbatim}

Input pour

\begin{exe}
\ex \textit{Jean prend une belle initiative.}
\end{exe}

\item 
\begin{verbatim}
sentence [HEAD:casser, i:[HEAD:Jean], 
ii:[HEAD:carafe, number:sg, def:yes, 
mod:<[HEAD:petit],[HEAD:blanc]>], 
diathesis:passive, tense:past, neg:yes, 
modV:<[HEAD:brutalement]>]
\end{verbatim}

Input contenant un trait passif négatif. La
production est
\begin{exe}
\ex \textit{La petite carafe blanche n'avait pas été cassée
brutalement par Jean.}
\end{exe}

\end{itemize}

\section{Écriture des grammaires}

\subsection{Schémas de conception}

Un shéma de conception s'applique dans un cas général qui peut être
résumé par quelques contraintes. Il n'est pas associé à un phénomène
linguistique en particulier, mais à une organisation récurrente de la
grammaire pour laquelle une réponse unique et cohérente doit être apportée.

\subsubsection*{A - Propagation locale des attributs synthétisés}

Un trait \texttt{A} qui doit contraindre une réalisation \texttt{R} en
génération telle de \texttt{R} ne dépende que du
lexique ou de la grammaire.

Exemples d'applications:
\begin{itemize}
\item Production d'un groupe nominal contraint dans une expression
  phraséologique
\item Conjugaison à la voix passive
\end{itemize}

La règle générale s'écrit

\begin{lstlisting}
X → Y {
  [A:$v, $rest];
  [ARealization:R] ⊂ ⇓1;
  ↓1 = [R:$v, $rest];
}
\end{lstlisting}

Exemple 1:
La production des compléments contraints dans une expression
  phraséologique. L'expression \textit{casser du sucre sur le dos de
quelqu'un} introduit la réalisation de deux compléments non actualisés
\textit{du sucre} et \textit{sur le dos de qqu'un}, et le second
complément (\textit{sur le dos}) contient un génitif qui est actualisé
dans l'énoncé par le patient de la clause.

\begin{exe}
\ex \textit{Ce rapport casse du sucre sur le dos \textbf{de la commission}.}
\ex \textit{La commission, c'est toujours sur \textbf{son} dos qu'on casse du sucre.}
\ex \textit{J'ai failli \textbf{te} casser du sucre sur le dos.}
\end{exe}

Il faut donc rendre compte de la réalisation des compléments constants
de l'expression et du patient sous la forme
d'un génétif dans une telle expression.

\begin{lstlisting}
VN → V [NP] [PP] {
  [obj:NIL, obl:NIL];
  [subj:$subj] ⊂ ↑;
  ↓1 = ↑;
  [objC:$objSynt, oblC:$oblSynt] ⊂ ⇓1;
  if (#2) {
    attest $objSynt;
    ↓2 = $objSynt;
  }
  else {
    attest ¬$objSynt;
  }
  if (#3) {
    attest $oblSynt;
    ↓3 = $oblSynt;
  }
  else {
    attest ¬$oblSynt;
  }
}

casser verb[HEAD:casser_du_sucre, 
	constI:[HEAD:sucre, part:yes],
	constII:[HEAD:sur, i:[HEAD:dos, 
		number:sg, def:yes, 
		genitive:$patient]],
	patient:$patient];
\end{lstlisting}


Exemple 2:
L'agent d'une clause se réalise par la fonction grammaticale sujet
pour une conjugaison à la voix active, et par la fonction oblique en
\og par\fg{} pour une conjugaison à la voix passive.

\begin{lstlisting}
// Réalisation d'un agent comme sujet
Sentence → Sentence {
  [agent:$agent, $rest];
  [agentRealization:subject] ⊂ ⇓1;
  ↓1 = [subject:$agent, $rest];
  ⇑ = ⇓1;
}

// Réalisation d'un agent comme objet prépositionnel
Sentence → Sentence {
  [agent:$agent, $rest];
  [agentRealization:oblBy] ⊂ ⇓1;
  ↓1 = [byObj:$agent, $rest];
  ⇑ = ⇓1;
}

// Réalisation d'un patient comme objet
Sentence → Sentence {
  [patient:$patient, agent:NIL, $rest];
  [patientRealization:object] ⊂ ⇓1;
  ↓1 = [object:$patient, $rest];
  ⇑ = ⇓1;
}

// Réalisation d'un patient comme sujet
Sentence → Sentence {
  [patient:$patient, agent:NIL, $rest];
  [patientRealization:subject] ⊂ ⇓1;
  ↓1 = [subject:$patient, $rest];
  ⇑ = ⇓1;
}

// Construction Passive 
Sentence → NP VERB PP {
  [subject:$subject, parObl:$parObl, $rest];
  ↓1 = $subject;
  ↓2 = $rest ∪ [voice:passive];
  ↓3 = $parObl;
  ⇑ = [agentRealization:oblBy, 
	patientRealization:subject];
}

// Construction Active
Sentence → NP VERB NP {
  [subject:$subject, object:$object, $rest];
  ↓1 = $subject;
  ↓2 = $rest ∪ [voice:active];
  ↓3 = $object;
  ⇑ = [agentRealization:subject, 
	patientRealization:object];
}
\end{lstlisting}

\subsubsection*{B - Transformation de l'attribut hérité par une tête syntaxique}

Un trait hérité \texttt{A} qui doit contraindre une réalisation
\texttt{R} par un nouveau prédicat en génération.

Exemples d'applications:
\begin{itemize}
\item Utilisation d'un auxiliaire de temps verbal ou de modalité
\item Conjugaison composée 
\end{itemize}

La règle générale s'écrit

\begin{lstlisting}
X → Y {
  [A:K];
  [HEAD:$HEAD, A:k, $Rest] ⊂ ↑;
  ↓1 = [HEAD:L, arg:[HEAD:$HEAD, $Rest]];
}

\end{lstlisting}

Exemple:
L'aspect se traduit par des formes conjuguées, mais aussi par des
constructions composées (\og être en train de + inf\fg{}, \og aller +
participe présent\fg{}, etc.). La catégorie grammaticale \texttt{aspect} 

\begin{lstlisting}
sentence → sentence {
  [aspect:progressive];
  [HEAD:$HEAD, aspect:progressive, i:$I, $Rest] ⊂ ↑;
  ↓1 = [HEAD:être_en_train_de, 
	i:[HEAD:$HEAD, i:$I, $Rest]];
  ⇑ = ⇓1;
}

\end{lstlisting}




\end{document}
